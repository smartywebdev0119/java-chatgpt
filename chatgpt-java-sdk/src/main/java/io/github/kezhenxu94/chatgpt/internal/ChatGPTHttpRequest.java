package io.github.kezhenxu94.chatgpt.internal;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.github.kezhenxu94.chatgpt.message.Message;

import java.util.List;
import java.util.Map;

@JsonInclude(JsonInclude.Include.NON_NULL)
public class ChatGPTHttpRequest {
  /** ID of the model to use. Currently, only gpt-3.5-turbo and gpt-3.5-turbo-0301 are supported. */
  private final String model = "gpt-3.5-turbo";

  /** The messages to generate chat completions for, in the chat format. */
  private final List<Message> messages;

  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output
   * more random, while lower values like 0.2 will make it more focused and deterministic.
   *
   * <p>We generally recommend altering this or top_p but not both.
   */
  private final double temperature;

  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers
   * the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising
   * the top 10% probability mass are considered.
   *
   * <p>We generally recommend altering this or temperature but not both.
   */
  @JsonProperty("top_p")
  private final double topP;

  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers
   * the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising
   * the top 10% probability mass are considered.
   *
   * <p>We generally recommend altering this or temperature but not both.
   */
  private final int n;

  /**
   * If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only
   * server-sent events as they become available, with the stream terminated by a `data: [DONE]`
   * message.
   */
  private final boolean stream;

  /**
   * The maximum number of tokens allowed for the generated answer. By default, the number of tokens
   * the model can return will be (4096 - prompt tokens).
   */
  @JsonProperty("max_tokens")
  private final Integer maxTokens;

  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear
   * in the text so far, increasing the model's likelihood to talk about new topics.
   */
  @JsonProperty("presence_penalty")
  private final double presencePenalty;

  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing
   * frequency in the text so far, decreasing the model's likelihood to repeat the same line
   * verbatim.
   */
  @JsonProperty("frequency_penalty")
  private final double frequencyPenalty;

  /**
   * Modify the likelihood of specified tokens appearing in the completion.
   *
   * <p>Accepts a json object that maps tokens (specified by their token ID in the tokenizer) to an
   * associated bias value from -100 to 100. Mathematically, the bias is added to the logits
   * generated by the model prior to sampling. The exact effect will vary per model, but values
   * between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100
   * should result in a ban or exclusive selection of the relevant token.
   */
  @JsonProperty("logit_bias")
  private final Map<String, String> logitBias;

  /**
   * A unique identifier representing your end-user, which can help OpenAI to monitor and detect
   * abuse. Learn more.
   */
  private final String user;

  ChatGPTHttpRequest(
      List<Message> messages,
      double temperature,
      double topP,
      int n,
      boolean stream,
      Integer maxTokens,
      double presencePenalty,
      double frequencyPenalty,
      Map<String, String> logitBias,
      String user) {
    this.messages = messages;
    this.temperature = temperature;
    this.topP = topP;
    this.n = n;
    this.stream = stream;
    this.maxTokens = maxTokens;
    this.presencePenalty = presencePenalty;
    this.frequencyPenalty = frequencyPenalty;
    this.logitBias = logitBias;
    this.user = user;
  }

  public static ChatGPTRequestBuilder builder() {
    return new ChatGPTRequestBuilder();
  }

  public String getModel() {
    return model;
  }

  public List<Message> getMessages() {
    return messages;
  }

  public double getTemperature() {
    return temperature;
  }

  public double getTopP() {
    return topP;
  }

  public int getN() {
    return n;
  }

  public boolean isStream() {
    return stream;
  }

  public Integer getMaxTokens() {
    return maxTokens;
  }

  public double getPresencePenalty() {
    return presencePenalty;
  }

  public double getFrequencyPenalty() {
    return frequencyPenalty;
  }

  public Map<String, String> getLogitBias() {
    return logitBias;
  }

  public String getUser() {
    return user;
  }
}
